{
  "version": 3,
  "sources": ["../src/rarity-levels.ts", "../src/hash-item.ts", "../src/main.ts", "../src/utils.ts", "../src/image.ts"],
  "sourcesContent": ["// Each rarity level is defined using a number that represents the maximum\n// number of occurences required to be in that level.\n// See scripts/generate-items-rarity.ts to see how it is used.\nexport default [\n  [-1, \"#838383\", \"Common\"],\n  [374, \"#00DC82\", \"Uncommon\"],\n  [357, \"#2e82ff\", \"Rare\"],\n  [100, \"#c13cff\", \"Epic\"],\n  [9, \"#f8b73e\", \"Legendary\"],\n  [1, \"#ff44b7\", \"Mythic\"],\n] as Array<[number, string, string]>;\n", "/**\n * This file is based on previous work:\n * shorthash2 (c) 2020 Jecsham https://github.com/jecsham/shorthash2 (MIT)\n * shorthash (c) 2013 Bibig https://github.com/bibig/node-shorthash (MIT)\n */\n\nconst DICT =\n  \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+,./:;<=>?@[]^_`{|}~\";\nconst PAD_CHAR = \"\u00A4\";\nconst HASH_LENGTH = 5;\n\nfunction bitwise(str: string) {\n  let hash = 0;\n  if (str.length == 0) return hash;\n  for (let i = 0; i < str.length; i++) {\n    let ch = str.charCodeAt(i);\n    hash = (hash << 5) - hash + ch;\n    hash = hash & hash;\n  }\n  return hash;\n}\n\nfunction binaryTransfer(integer: number, binary?: number) {\n  binary = binary || DICT.length;\n  let stack = [];\n  let num: number;\n  let result = \"\";\n  const sign = integer < 0 ? \"-\" : \"\";\n  integer = Math.abs(integer);\n  while (integer >= binary) {\n    num = integer % binary;\n    integer = Math.floor(integer / binary);\n    stack.push(DICT[num]);\n  }\n  if (integer > 0) {\n    stack.push(DICT[integer]);\n  }\n  for (var i = stack.length - 1; i >= 0; i--) {\n    result += stack[i];\n  }\n  return sign + result;\n}\n\nfunction shorthash(text: string) {\n  let type = typeof text;\n  if (type === \"string\" || type === \"number\") {\n    const id = binaryTransfer(bitwise(String(text)), DICT.length - 1);\n    return id.replace(\"-\", \"Z\");\n  } else {\n    throw new Error(\"Unexpected input type\");\n  }\n}\n\nexport function hashItem(name: string): string {\n  return shorthash(name).slice(0, HASH_LENGTH).padStart(HASH_LENGTH, PAD_CHAR);\n}\n", "import type { ColorFn, RarityLevel } from \"./types\";\n\nimport itemsRarity from \"../data/items-rarity-hashes.json\";\nimport { hashItem } from \"./hash-item\";\nimport rarityLevels from \"./rarity-levels\";\n\nlet cachedItemsrarity = null;\n\nexport function itemRarity(itemName: string): RarityLevel {\n  if (!cachedItemsrarity) {\n    cachedItemsrarity = itemsRarity.map(\n      (items: string) => new Set(items.match(/.{1,5}/g))\n    );\n  }\n\n  const hash = hashItem(itemName);\n\n  let index = 5;\n  while (index--) {\n    if (cachedItemsrarity[index].has(hash)) {\n      return (index + 2) as RarityLevel;\n    }\n  }\n  return 1;\n}\n\nexport function rarityColor(\n  itemOrRarity: string | RarityLevel,\n  { colorFn }: { colorFn?: ColorFn } = {}\n): string {\n  const itemName = typeof itemOrRarity === \"string\" ? itemOrRarity : null;\n  const level = itemName ? itemRarity(itemName) : (itemOrRarity as RarityLevel);\n\n  const color = rarityLevels[level - 1][1];\n  if (!color) {\n    throw new Error(`Incorrect rarity level or item: ${itemOrRarity}`);\n  }\n  return (colorFn?.({ color, itemName, level }) || color) as string;\n}\n\nexport function rarityDescription(itemOrRarity: string | RarityLevel): string {\n  const rarity =\n    typeof itemOrRarity === \"number\" ? itemOrRarity : itemRarity(itemOrRarity);\n\n  const description = rarityLevels[rarity - 1][2];\n  if (!description) {\n    throw new Error(`Incorrect rarity passed: ${itemOrRarity}`);\n  }\n  return description;\n}\n", "import fetch from \"cross-fetch\";\n\nexport function isUri(data: string) {\n  return /^(?:https?|data)\\:/.test(data);\n}\n\nexport function dataUri(mediaType: string, data: string): string {\n  return `data:${mediaType},${encodeURIComponent(data)}`;\n}\n\nexport async function fetchOrDecodeDataUri(dataOrUrl: string): Promise<string> {\n  if (dataOrUrl.startsWith(\"http\") || typeof Buffer === \"undefined\") {\n    return fetch(dataOrUrl).then((res) => res.text());\n  }\n\n  if (!dataOrUrl.startsWith(\"data:\")) {\n    throw new Error(\"Protocol not supported: \" + dataOrUrl);\n  }\n\n  // Probably a node environment. Since cross-fetch doesn\u2019t support data: URLs\n  // yet in node environments, we have to do this manually. Note: node-fetch\n  // 3.0 has been released and supports data: URLs, but cross-fetch hasn\u2019t\n  // updated this dependency yet.\n  const separator = dataOrUrl.indexOf(\",\");\n  const [prefix, data] = [\n    dataOrUrl.slice(0, separator),\n    dataOrUrl.slice(separator + 1),\n  ];\n  const isBase64 = prefix.includes(\";base64\");\n\n  return isBase64\n    ? Buffer.from(data, \"base64\").toString()\n    : decodeURIComponent(data);\n}\n", "import type { ColorFn } from \"./types\";\n\nimport { rarityColor, rarityDescription } from \"./main\";\nimport { dataUri, fetchOrDecodeDataUri, isUri } from \"./utils\";\n\ntype Options = {\n  colorFn?: ColorFn;\n  displayLevels?: boolean;\n  imageFormat?: \"data-uri\" | \"svg\";\n};\n\nconst SVG_START =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'preserveAspectRatio=\"xMinYMin meet\" ' +\n  'viewBox=\"0 0 350 350\">' +\n  \"<style>\" +\n  \"text { font-family: serif; font-size: 14px; }\" +\n  \"</style>\" +\n  '<rect width=\"100%\" height=\"100%\" fill=\"black\" />';\nconst SVG_END = \"</svg>\";\n\nconst MATCH_ITEM_TEXT = /<text[^>]+\\>([^<]+)<\\/text>/;\n\nexport function itemsFromSvg(svg: string) {\n  if (!svg.startsWith(\"<svg\")) {\n    throw new Error(\"The svg paramater doesn\u2019t seem to be an SVG\");\n  }\n\n  let matches: null | string[];\n  const items = [];\n  for (let i = 0; i < 8; i++) {\n    matches = svg.match(MATCH_ITEM_TEXT);\n    if (!matches) {\n      if (items.length === 0) {\n        throw new Error(\n          \"Error when parsing the SVG: couldn\u2019t find the next item\"\n        );\n      }\n      // Probably a LootLoose image\n      return items;\n    }\n    items.push(matches[1]);\n    svg = svg.slice(svg.indexOf(matches[0]) + matches[0].length);\n  }\n  return items;\n}\n\nexport function rarityImageFromItems(\n  items: string[],\n  { colorFn, imageFormat = \"data-uri\", displayLevels = false }: Options = {}\n) {\n  if (items.length < 1) {\n    throw new Error(\"A bag should contain at least one item\");\n  }\n\n  const svg = [\n    SVG_START,\n    ...items.map((item, index) => {\n      const y = 20 * (index + 1);\n      const level = displayLevels\n        ? ` (${rarityDescription(item).slice(0, 1)})`\n        : \"\";\n      const color = rarityColor(item, { colorFn });\n      return (\n        `<text x=\"10\" y=\"${y}\" fill=\"${color}\">` + item + level + `</text>`\n      );\n    }),\n    SVG_END,\n  ].join(\"\");\n\n  return imageFormat === \"data-uri\" ? dataUri(\"image/svg+xml\", svg) : svg;\n}\n\nconst INPUT_ERROR =\n  \"The resource doesn\u2019t seem to be a Loot SVG, a Loot metadata, or a URL pointing to it\";\n\nexport async function rarityImage(\n  svgOrSvgUriOrItems: string | string[],\n  options?: Options\n): Promise<string> {\n  if (Array.isArray(svgOrSvgUriOrItems)) {\n    return rarityImageFromItems(svgOrSvgUriOrItems);\n  }\n\n  let svg = svgOrSvgUriOrItems;\n\n  // Accepts the metadata string as returned by tokenURI()\n  if (svg.startsWith(\"data:application/json\")) {\n    try {\n      svg = JSON.parse(await fetchOrDecodeDataUri(svg)).image;\n    } catch (err) {\n      throw new Error(INPUT_ERROR);\n    }\n  }\n\n  // Fetch URLs or parse data URIs\n  if (isUri(svg)) {\n    svg = await fetchOrDecodeDataUri(svg);\n  }\n\n  if (!svg.startsWith(\"<svg\")) {\n    throw new Error(INPUT_ERROR);\n  }\n\n  const items = itemsFromSvg(svg);\n  return rarityImageFromItems(items, options);\n}\n"],
  "mappings": "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",
  "names": []
}
